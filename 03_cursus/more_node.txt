0
1
2
3 <- down from upper part (pos 3) 
4
3 <- up from down part (pos 3)
2
1

up from down part (pos 3)
8 - 3 = 5
len - pos

down from upper part (pos 3)
8 - 3 = 5
len - pos


update shortcut /////////////////////////////////////////////////////////////////////
A=>goal: 5| pos: 0| upper: 1| cost: 2| mov:1| val:  53|		B=>inst A:  4| inst B:  0| goal: 3| pos: 0| upper: 1| cost: 2| mov:1| tar: 4| val:  29|	
A=>goal: 6| pos: 1| upper: 1| cost:-1| mov:0| val:  54|		B=>inst A: -1| inst B:  1| goal: 2| pos: 1| upper: 1| cost: 3| mov:0| tar: 4| val:  24|	
A=>goal: 8| pos: 2| upper: 1| cost:-1| mov:0| val:  82|		B=>inst A: -2| inst B:  2| goal: 0| pos: 2| upper: 0| cost: 3| mov:0| tar: 1| val:   1|	
A=>goal: 1| pos: 2| upper: 0| cost:-1| mov:0| val:  20|		B=>inst A:  2| inst B: -1| goal: 7| pos: 1| upper: 0| cost: 3| mov:1| tar: 8| val:  62|	
A=>goal: 4| pos: 1| upper: 0| cost: 2| mov:1| val:  39|	


upper=true move_up=false => -
len - pos
if pos is 0 ten return 0

upper=false move_up=false => -
pos

upper=true move_up=true => +
pos

upper=false move_up=true => +
len - pos

update shortcut /////////////////////////////////////////////////////////////////////
A=>goal: 1| pos: 0| upper: 1| cost:-1| mov:0| val:  20|		B=>inst A:  1| inst B:  0| goal: 4| pos: 0| upper: 1| cost: 2| mov:1| tar: 6| val:  39|	
A=>goal: 6| pos: 1| upper: 1| cost:-1| mov:0| val:  54|		B=>inst A:  1| inst B:  1| goal: 5| pos: 1| upper: 1| cost: 2| mov:1| tar: 6| val:  53|	
A=>goal: 8| pos: 1| upper: 0| cost:-1| mov:0| val:  82|		B=>inst A:  1| inst B:  2| goal: 3| pos: 2| upper: 1| cost: 3| mov:0| tar: 6| val:  29|	
								B=>inst A:  1| inst B:  0| goal: 2| pos: 3| upper: 0| cost: 5| mov:0| tar: 6| val:  24|	<== bug!!! ist b 0
								B=>inst A:  0| inst B: -2| goal: 0| pos: 2| upper: 0| cost: 3| mov:0| tar: 1| val:   1|	
								B=>inst A: -1| inst B: -1| goal: 7| pos: 1| upper: 0| cost: 2| mov:1| tar: 8| val:  62|	
								
-> below, a => move_up=true 

## not counting the cost correctly for the moves, is importend to decide which is the shortes algo
### wrong 
diff direction
when B is 0 always giving back 0 even if A is higher (correct when A is 0)

./push_swap 62 1 24 29 53 39 20 54 82


